javaSE

1.基础部分的顺序
 基本语法，类相关的语法，内部类的语法，继承相关的语法，异常的语法，线程的语法，集合的语法，io的语法，虚拟机方法的语法

2.一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？

 可以有多个类，但只能有一个public类,并且public的类名必须与文件名一致

3.重载和重写的区别
 重写出现在继承关系中,子类根据自己的需要重写父类中的方法,当然父类中private修饰和final修饰的方法不能被重写,重写后子类对象调用该方法时就会执行子类中重写的方法,而不会再调用父类中对应的方法。重载指在一个类中,方法名相同,但参数列表不同的多个方法,参数列表不同是指数量不同,类型不同,顺序不同
 
4.抽象类是什么
 抽象类是使用abstract关键字修饰的类,这种类不能被实例化,并且可以有普通方法和抽象方法,抽象方法是指没有方法体的方法,需要在子类中重写得以实现,抽象类存在的意义是作为父类存在,主要用于被继承,所以类不能用final修饰,当一个类继承自一个抽象类,必须要实现抽象类中定义的所有的抽象方法,除非该类也是一个抽象类
 
5.接口是什么
 接口中不能有普通方法和实例变量,接口中定义的都是抽象方法和常量,所以它比抽象类更抽象,接口中定义的方法主要用于被类实现,一个类可以实现多个接口,实现接口后,必须实现接口中定义的所有方法,除非该类也是抽象类,接口之间可以继承neg,并可以是多继承
 
6.多态是什么
 多态在java中的主要表现为父类指向子类,接口指向实现类对象,这样做的好处就是降低类之间的耦合性 eg:方法采用父类作为参数,那么不仅可以传入父类对象,还可以传入所有子类对象,采用一个接口作为方法的参数,可以传入该接口所有实现类的对象
 
7.类型转换异常(java.lang.ClassCastException)
 进行强制类型转换的时候产生的异常,一般是在父类引用指向子类对象时出现,如果父类引用指向子类对象的类型不是目标子类类型而进行强制类型转换时将产生类型转换异常
 
8.面向对象的特征

 面向对象的三大特征分别是封装,继承和多态
 封装是面向对象的基础,目标是为了实现高内聚低耦合,类是封装的基本形式,类中包含了属性和方法,属性描述了类的特征,方法描述了类的行为
 继承的用途主要是为了代码的复用,当子类继承父类后,可以拥有父类中定义的属性和方法,在继承中,被继承的类成为父类,继承的类成为子类
 多态在java中的主要表现为父类指向子类,接口指向实现类对象,这样做的好处就是降低类之间的耦合性
 
9.ArrayList和LinkedList的区别

 ArrayList和LinkedList在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下： 
 1)．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。
 2)．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。

 3)．LinkedList不支持高效的随机元素访问。
 4)．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间
 可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。
 
10.HashMap和ConcurrentHashMap的区别
 jdk1.2起就HashMap,线程不安全的
 jdk1.5Concurrent包,线程安全的
 ConcurrentHashMap引入了"分段锁"，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。
 在ConcurrentHashMap中，就是把Map分成了N个Segment(相当于HashTable)，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。
 ConcurrentHashMap中默认是把segments初始化为长度为16的数组。
根据ConcurrentHashMap.segmentFor的算法，线程1和线程2,的值3、4对应的Segment都是segments[1]，线程3的值7对应的Segment是segments[12]。

（1）Thread1和Thread2先后进入Segment.put方法时，Thread1会首先获取到锁，可以进入，而Thread2则会阻塞在锁上：
（2）切换到Thread3，也走到Segment.put方法，因为7所存储的Segment和3、4不同，因此，不会阻塞在lock();
 以上就是ConcurrentHashMap的工作机制，通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。
 
11.线程安全与可重入函数

 ?概念
 重入：即重复调用，函数被不同的流调用，有可能会出现第一次调用还没返回时就再次进入该函数开始下一次调用。

 可重入：当程序被多个线程反复执行，产生的结果正确。

 如果一个函数只访问自己的局部变量或参数，称为可重入函数。

 不可重入：当程序被多个线程反复调用，产生的结果出错。

 当函数访问一个全局的变量或者参数时，有可能因为重入而造成混乱，像这样的函数称为不可重入函数。
 线性安全：一般来说，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。

 ?可重入特点
 由于可重入函数多次调用不会出错，因此可重入函数不用担心数据会被破坏。可重入函数任何时候都可以被中断，一段时间后又可以运行，而相应的数据不会丢失。可重入函数只使用局部变量，即保存在CPU寄存器或者堆栈中；或者如果使用全局变量时，则要对全局变量予以保护。

 ?不可重入特点

 如果一个函数符合以下条件之一的，则是不可重入的：

（1）调用了malloc/free函数，因为malloc函数是用全局链表来管理堆的。

（2）调用了标准I/O库函数，标准I/O库的很多实现都以不可重入的方式使用全局数据结构。

（3）可重入体内使用了静态的数据结构。


 线程安全与可重入函数的区别
 (1)、可重入函数是线程安全函数的一种，其特点在于它们被多个线程调用时，不会引用任何共享数据。
 (2)、线程安全是在多个线程情况下引发的，而可重入函数可以在只有一个线程的情况下来说。
 (3)、线程安全不一定是可重入的，而可重入函数则一定是线程安全的。
 (4)、如果一个函数中有全局变量，那么这个函数既不是线程安全也不是可重入的。
 (5).如果将对临界资源的访问加上锁，则这个函数是线程安全的，但如果这个重入函数若锁还未释放则会产生死锁，因此是不可重入的。
 (6)、线程安全函数能够使不同的线程访问同一块地址空间，而可重入函数要求不同的执行流对数据的操作互不影响使结果是相同的。
 

 






























  