javaSE

1.基础部分的顺序
 基本语法，类相关的语法，内部类的语法，继承相关的语法，异常的语法，线程的语法，集合的语法，io的语法，虚拟机方法的语法

2.一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？

 可以有多个类，但只能有一个public类,并且public的类名必须与文件名一致

3.重载和重写的区别
 重写出现在继承关系中,子类根据自己的需要重写父类中的方法,当然父类中private修饰和final修饰的方法不能被重写,重写后子类对象调用该方法时就会执行子类中重写的方法,而不会再调用父类中对应的方法。重载指在一个类中,方法名相同,但参数列表不同的多个方法,参数列表不同是指数量不同,类型不同,顺序不同
 
4.抽象类是什么
 抽象类是使用abstract关键字修饰的类,这种类不能被实例化,并且可以有普通方法和抽象方法,抽象方法是指没有方法体的方法,需要在子类中重写得以实现,抽象类存在的意义是作为父类存在,主要用于被继承,所以类不能用final修饰,当一个类继承自一个抽象类,必须要实现抽象类中定义的所有的抽象方法,除非该类也是一个抽象类
 
5.接口是什么
 接口中不能有普通方法和实例变量,接口中定义的都是抽象方法和常量,所以它比抽象类更抽象,接口中定义的方法主要用于被类实现,一个类可以实现多个接口,实现接口后,必须实现接口中定义的所有方法,除非该类也是抽象类,接口之间可以继承neg,并可以是多继承
 
6.多态是什么
 多态在java中的主要表现为父类指向子类,接口指向实现类对象,这样做的好处就是降低类之间的耦合性 eg:方法采用父类作为参数,那么不仅可以传入父类对象,还可以传入所有子类对象,采用一个接口作为方法的参数,可以传入该接口所有实现类的对象
 
7.类型转换异常(java.lang.ClassCastException)
 进行强制类型转换的时候产生的异常,一般是在父类引用指向子类对象时出现,如果父类引用指向子类对象的类型不是目标子类类型而进行强制类型转换时将产生类型转换异常
 
8.面向对象的特征

 面向对象的三大特征分别是封装,继承和多态
 封装是面向对象的基础,目标是为了实现高内聚低耦合,类是封装的基本形式,类中包含了属性和方法,属性描述了类的特征,方法描述了类的行为
 继承的用途主要是为了代码的复用,当子类继承父类后,可以拥有父类中定义的属性和方法,在继承中,被继承的类成为父类,继承的类成为子类
 多态在java中的主要表现为父类指向子类,接口指向实现类对象,这样做的好处就是降低类之间的耦合性
 
9.ArrayList和LinkedList的区别

 ArrayList和LinkedList在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下： 
 1)．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。
 2)．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。

 3)．LinkedList不支持高效的随机元素访问。
 4)．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间
 可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。
 
10.HashMap和ConcurrentHashMap的区别
 jdk1.2起就HashMap,线程不安全的
 jdk1.5Concurrent包,线程安全的
 ConcurrentHashMap引入了"分段锁"，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。
 在ConcurrentHashMap中，就是把Map分成了N个Segment(相当于HashTable)，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。
 ConcurrentHashMap中默认是把segments初始化为长度为16的数组。
根据ConcurrentHashMap.segmentFor的算法，线程1和线程2,的值3、4对应的Segment都是segments[1]，线程3的值7对应的Segment是segments[12]。

（1）Thread1和Thread2先后进入Segment.put方法时，Thread1会首先获取到锁，可以进入，而Thread2则会阻塞在锁上：
（2）切换到Thread3，也走到Segment.put方法，因为7所存储的Segment和3、4不同，因此，不会阻塞在lock();
 以上就是ConcurrentHashMap的工作机制，通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。
 
11.线程安全与可重入函数

	概念
	 重入：即重复调用，函数被不同的流调用，有可能会出现第一次调用还没返回时就再次进入该函数开始下一次调用。

	 可重入：当程序被多个线程反复执行，产生的结果正确。

	 如果一个函数只访问自己的局部变量或参数，称为可重入函数。

	 不可重入：当程序被多个线程反复调用，产生的结果出错。

	 当函数访问一个全局的变量或者参数时，有可能因为重入而造成混乱，像这样的函数称为不可重入函数。
	 线性安全：一般来说，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。

	 ?可重入特点
	 由于可重入函数多次调用不会出错，因此可重入函数不用担心数据会被破坏。可重入函数任何时候都可以被中断，一段时间后又可以运行，而相应的数据不会丢失。可重入函数只使用局部变量，即保存在CPU寄存器或者堆栈中；或者如果使用全局变量时，则要对全局变量予以保护。

	 ?不可重入特点

	 如果一个函数符合以下条件之一的，则是不可重入的：

	（1）调用了malloc/free函数，因为malloc函数是用全局链表来管理堆的。

	（2）调用了标准I/O库函数，标准I/O库的很多实现都以不可重入的方式使用全局数据结构。

	（3）可重入体内使用了静态的数据结构。


	 线程安全与可重入函数的区别
	 (1)、可重入函数是线程安全函数的一种，其特点在于它们被多个线程调用时，不会引用任何共享数据。
	 (2)、线程安全是在多个线程情况下引发的，而可重入函数可以在只有一个线程的情况下来说。
	 (3)、线程安全不一定是可重入的，而可重入函数则一定是线程安全的。
	 (4)、如果一个函数中有全局变量，那么这个函数既不是线程安全也不是可重入的。
	 (5).如果将对临界资源的访问加上锁，则这个函数是线程安全的，但如果这个重入函数若锁还未释放则会产生死锁，因此是不可重入的。
	 (6)、线程安全函数能够使不同的线程访问同一块地址空间，而可重入函数要求不同的执行流对数据的操作互不影响使结果是相同的。
 
12.重写

	总结来说为：
	方法名相同，参数类型相同
	子类返回类型等于父类方法返回类型，
	子类抛出异常小于等于父类方法抛出异常，
	子类访问权限大于等于父类方法访问权限。

	详细的说明为：
	重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。 即外壳不变，核心重写！
	重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。

	重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常IOException，但是在重写这个方法的时候不能抛出Exception异常，因为Exception是IOException的父类，只能抛出IOException的子类异常。

	方法的重写规则
	1）参数列表必须完全与被重写方法的相同；
	2）返回类型必须完全与被重写方法的返回类型相同；（备注:这条信息是标准的重写方法的规则,但是在java 1.5 版本之前返回类型必须一样,1.5(包含)j 版本之后ava放宽了限制,返回类型必须小于或者等于父类方法的返回类型 ）。才有了
	子类返回类型小于等于父类方法返回类型。在java里面这个怎么样都是正确的,请小伙伴谨记。
	3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
	4）父类的成员方法只能被它的子类重写。
	5）声明为final的方法不能被重写。
	6）声明为static的方法不能被重写，但是能够被再次声明。
	7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
	8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
	9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
	10）构造方法不能被重写。
	11）如果不能继承一个方法，则不能重写这个方法。

13.什么是java虚拟机
   java虚拟机是一个可以执行java字节码的虚拟机进程。
   java源文件被编译成能被java虚拟机执行的字节码文件。
   java被设计成允许应用程序可以运行在任意的平台,而不需要程序员为每一个平台单独重写或者是重新编译。
   java虚拟机让这个变为可能,因为他知道底层硬件平台的指令长度和其他特性
   
14.HashMap与HashTable的区别
	
	HashMap和HashTable都实现了Map接口。主要区别：线程安全性，同步，以及速度
	(1).HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。
	(2).HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。
	(3).另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。
	(4).由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。
	
	(5).HashMap不能保证随着时间的推移Map中的元素次序是不变的。
	
	要注意的一些重要术语：
	1) sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。

	2) Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。

	3) 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。

	我们能否让HashMap同步？
	HashMap可以通过下面的语句进行同步：
	Map m = Collections.synchronizeMap(hashMap);

	结论
	Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。
	
	Hashtable和HashMap到底有哪些不同呢
	(1).基类不同：HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。
	(2).null不同：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。
	(3).线程安全：HashMap时单线程安全的，Hashtable是多线程安全的。

	(4).遍历不同：HashMap仅支持Iterator的遍历方式，Hashtable支持Iterator和Enumeration两种遍历方式。
	
15.

	
 






























  